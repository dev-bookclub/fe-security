# HTTP 통신 프로토콜과 보안

웹 애플리케이션이 동작하는 핵심 원리 중 하나는 HTTP(HyperText Transfer Protocol), HTTP는 브라우저와 서버 간의 데이터 전송을 담당하는 통신 프로토콜이며, 보안이 중요한 요소가 된다.

---

## 1. HTTP란?

HTTP(HyperText Transfer Protocol)은 클라이언트(브라우저)와 서버 간에 데이터를 주고받는 프로토콜이다. HTTP를 사용하면 브라우저가 웹 페이지를 요청하고, 서버에서 HTML, CSS, JavaScript 등의 리소스를 제공하여 웹 애플리케이션을 동작시킬 수 있다.

### HTTP의 주요 특징

- **무상태(Stateless)**: 각 요청은 독립적이며, 이전 요청의 정보를 기억하지 않는다.
- **텍스트 기반**: 사람이 읽을 수 있는 텍스트 형식으로 요청 및 응답을 주고받는다.
- **클라이언트-서버 구조**: 클라이언트가 요청을 보내고 서버가 응답을 반환하는 방식이다.

---

## 2. 브라우저의 HTTP 통신 과정

웹사이트에 접속하는 과정은 다음과 같은 순서로 이루어진다.

1. 사용자가 **URL 입력** (예: `https://example.com`)
2. **DNS 조회**를 통해 웹사이트 서버의 IP 주소 확인
3. 서버에 **HTTP 요청** 전송 (예: `GET /index.html HTTP/1.1`)
4. 서버에서 **HTTP 응답** 반환 (예: `200 OK` 및 HTML 파일 전달)
5. 브라우저가 **웹 페이지 렌더링** 및 추가 리소스 요청 (CSS, JS, 이미지 등)

---

## 3. HTTP와 TCP/IP

HTTP는 **TCP/IP 프로토콜 스택** 위에서 동작한다. TCP/IP는 데이터를 신뢰성 있게 전송하는 데 사용되며, 아래와 같이 4계층으로 구성된다.

| 계층               | 역할                     | 주요 프로토콜   |
| ------------------ | ------------------------ | --------------- |
| 응용 계층          | 애플리케이션 통신        | HTTP, SMTP      |
| 전송 계층          | 데이터 전송 및 오류 감지 | TCP, UDP        |
| 인터넷 계층        | 데이터 패킷 라우팅       | IP              |
| 네트워크 접속 계층 | 물리적 데이터 전송       | Ethernet, Wi-Fi |

### TCP와 UDP의 차이점

#### TCP (Transmission Control Protocol)

- 데이터의 신뢰성을 보장하는 프로토콜이다.
- 패킷이 순서대로 도착하도록 보장하며, 손실된 패킷을 재전송한다.
- 연결 지향적(Connection-oriented)이며, 3-way handshake를 사용하여 연결을 설정한다.
- 웹 페이지 로딩, 파일 다운로드 등 신뢰성이 중요한 작업에서 사용된다.

ex) 정적 리소스 요청, 페이지가 제대로 로드되려면 모든 리소스가 순서대로 도착해야 하므로 신뢰성 보장된 TCP가 적합!

#### UDP (User Datagram Protocol)

- 속도를 우선시하는 프로토콜이다.
- 패킷이 손실되거나 순서가 바뀌어도 별다른 조치를 취하지 않는다.
- 연결 없이 데이터를 전송하는 비연결형(Connectionless) 방식이다.
- 실시간 스트리밍, VoIP(인터넷 전화), 온라인 게임 등 빠른 응답이 중요한 작업에서 사용된다.

ex) WebRTC 기반 영상 통화, 실시간 채팅, 게임 등! 약간 패킷 손실이 있어도 전체적인 흐름이 유지되는것이 중요

> Q? 패킷손실 TCP처럼 재전송 안하면 어떻게?
> -> 클라측에서 예측 알고리즘 or 패킷 재용청 같은 보완 기술 적용해 손실 최소화!

**전송 계층에서 TCP와 UDP로 나뉘는가?**
-> 전송 계층(Transport Layer)에서 데이터의 전송 방식을 결정하는 두 가지 주요 프로토콜이 'TCP'와 'UDP'이다. 보통 HTTP/1.1과 HTTP/2는 'TCP 기반', HTTP/3는 'UDP 기반'으로 작동한다.

---

## 4. HTTP 메시지 구조

### 4.1 HTTP 요청 메시지

클라이언트가 서버에 보내는 HTTP 요청은 **요청 라인**, **헤더(Header)**, **바디(Body)**로 구성된다.

#### 예제 요청 메시지

```http
POST /login HTTP/1.1
Host: example.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded

username=user&password=1234
```

### 4.2 HTTP 응답 메시지

서버가 클라이언트에 보내는 HTTP 응답은 **상태 라인**, **헤더(Header)**, **바디(Body)**로 구성된다.

#### 예제 응답 메시지

```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 648

<!DOCTYPE html>
<html>...</html>
```

---

## 5. HTTP 메서드

HTTP 요청에서 사용되는 주요 메서드는 다음과 같다.

| 메서드    | 설명                   | 부작용 여부                   |
| --------- | ---------------------- | ----------------------------- |
| `GET`     | 리소스를 요청          | 없음 (안전)                   |
| `HEAD`    | 헤더 정보만 요청       | 없음 (안전)                   |
| `POST`    | 데이터를 전송하여 생성 | 있음 (위험)                   |
| `PUT`     | 데이터를 업데이트      | 있음 (위험)                   |
| `DELETE`  | 데이터를 삭제          | 있음 (위험)                   |
| `CONNECT` | 터널링을 위한 메서드   | 있음 (위험)                   |
| `OPTIONS` | 지원하는 메서드 조회   | 없음 (안전)                   |
| `TRACE`   | 요청을 그대로 반환     | 보안 취약점으로 사용하지 않음 |

---

## 6. HTTP 상태 코드

서버의 응답 상태를 나타내는 HTTP 상태 코드는 다음과 같이 분류된다.

| 코드  | 설명                                        |
| ----- | ------------------------------------------- |
| `1xx` | 요청 진행 중                                |
| `2xx` | 요청 성공 (예: `200 OK`)                    |
| `3xx` | 리소스 이동 (예: `301 Moved Permanently`)   |
| `4xx` | 클라이언트 오류 (예: `404 Not Found`)       |
| `5xx` | 서버 오류 (예: `500 Internal Server Error`) |

---

## 7. 안전한 통신을 위한 HTTPS

HTTP 통신에는 세 가지 주요 보안 약점이 존재한다.

| 보안 문제                      | 설명                                                                                                                                                                                                                                          |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **통신 데이터 암호화 부족**    | HTTP는 데이터를 암호화하지 않기 때문에 공격자가 네트워크를 도청할 수 있다. 예를 들어 사용자가 로그인할 때 패스워드가 평문으로 전송되면 공격자는 이를 쉽게 가로챌 수 있다. 따라서 데이터를 암호화하여 보호하는 구조가 필요하다.                |
| **통신 상대의 진위 확인 불가** | HTTP는 상대 서버의 신원을 검증하는 시스템이 없기 때문에 공격자가 요청 URL을 조작하여 사용자를 피싱 사이트로 유도할 수 있다. 브라우저는 URL을 기반으로 서버를 신뢰하므로, 이를 예방하기 위해 통신 상대의 진위 여부를 확인하는 구조가 필요하다. |
| **데이터 무결성 보장 어려움**  | HTTP는 데이터가 변조되었는지 확인할 수 있는 방법이 없으므로, 공격자가 중간에서 데이터를 조작해도 이를 감지할 수 없다. 따라서 데이터가 변경되지 않았음을 보장하는 기능이 필요하다.                                                             |

<br/>

#### HTTP 보안 강화를 위한 TLS (HTTPS)

위의 보안 문제를 해결하기 위해 **TLS(Transport Layer Security)**를 활용한 **HTTPS(HTTP over TLS)**가 사용된다. HTTPS는 HTTP 통신 전에 TLS 핸드셰이크 과정을 통해 보안을 강화한다.

| 보안 기능              | 설명                                                                                                                                                                                                                                                                                      |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **통신 데이터 암호화** | TLS는 통신 데이터를 암호화하여 도청을 방지한다. 암호화 및 복호화에 필요한 키는 브라우저와 서버 간의 안전한 통신 과정을 통해 공유되며, 해당 키가 없으면 데이터의 내용을 해독할 수 없다.                                                                                                    |
| **통신 상대 검증**     | TLS는 전자 인증서를 사용하여 통신 상대의 신원을 확인한다. 인증서는 **CA(Certificate Authority, 인증 기관)**에서 발급되며, 브라우저는 받은 인증서를 검증하고 신뢰할 수 있는 인증 기관의 목록과 대조하여 유효성을 판단한다. 인증서가 유효하지 않으면 브라우저는 사용자에게 경고를 표시한다. |
| **데이터 무결성 보장** | TLS는 데이터 변조 여부를 확인하는 기능을 제공한다. 데이터가 전송될 때 **인증 태그**를 생성하여 함께 전송하며, 수신자가 이를 검증하여 변조 여부를 확인할 수 있다. 변조가 감지되면 브라우저는 오류를 표시하고 해당 데이터를 무효화한다.                                                     |

<br/>

### 안전한 컨텍스트 (Secure Context)

브라우저에서 제공하는 강력한 기능은 **Secure Context(보안 컨텍스트)**에서만 사용할 수 있도록 제한된다. 다음 조건을 충족하는 경우 보안 컨텍스트로 간주된다.

- `https://` 또는 `wss://` 같은 암호화된 통신을 사용
- `http://localhost`, `127.0.0.1`, `file://` 등 로컬 환경에서 실행

예를 들어, 카드 결제 기능, 브라우저의 고급 API(Web Bluetooth, WebUSB, WebRTC 등)는 보안 컨텍스트에서만 동작한다.

<br/>

#### Mixed Content(혼합 콘텐츠)의 위험성

웹사이트가 HTTPS를 사용하더라도 내부 리소스(이미지, 스크립트, CSS 등)를 HTTP로 로드하면 보안이 약화된다. 이를 **Mixed Content(혼합 콘텐츠)**라고 한다. 혼합 콘텐츠는 두 가지 유형이 있다.

##### 패시브 혼합 콘텐츠

- 이미지, 오디오, 비디오 파일과 같이 **사용자의 직접적인 입력을 받지 않는 콘텐츠**
- 예: HTTP에서 불러온 이미지가 HTTPS 페이지에 표시됨
- 보안 위험은 낮지만, HTTPS 보안을 약화시킬 수 있음

##### 액티브 혼합 콘텐츠

- 스크립트, CSS, AJAX 요청 등 **웹 페이지 동작에 영향을 주는 콘텐츠**
- 예: HTTP에서 로드된 JavaScript가 HTTPS 페이지에서 실행됨
- 공격자가 악성 스크립트를 삽입할 수 있어 보안 위협이 큼
- 대부분의 브라우저는 이를 기본적으로 차단함

<br/>

#### HSTS(HTTP Strict Transport Security)

HTTPS를 사용하더라도, 사용자가 HTTP로 접속할 가능성이 있다. 이를 방지하기 위해 **HSTS(HTTP Strict Transport Security)**를 사용하여 **모든 요청을 HTTPS로 강제할 수 있다.**

### 6.1 HSTS 동작 방식

1. 서버가 응답 헤더에 `Strict-Transport-Security`를 포함하여 브라우저에게 HTTPS만 사용할 것을 지시
2. 브라우저는 이후 해당 사이트에 대한 요청을 자동으로 HTTPS로 변환
3. 사용자가 HTTP URL을 입력해도 브라우저가 HTTPS로 강제 변환

#### HSTS 적용 예제

```http
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

- `max-age=31536000`: 1년 동안 HTTPS 강제
- `includeSubDomains`: 하위 도메인에도 적용

##### HSTS의 필요성

- 사용자가 **HTTP로 접속하는 순간 공격자가 개입**할 수 있기 때문에 이를 방지함
- 예: 처음 방문 시 HTTP로 접속하는 경우 공격자가 HTTPS로 전환하기 전에 트래픽을 가로챌 수 있음 (**중간자 공격, MITM**)
- HSTS를 사용하면 브라우저가 **HTTP를 아예 시도하지 않도록 강제**함

##### HSTS Preload 목록

HSTS를 설정해도 처음 방문 시에는 HTTP를 시도할 수 있기 때문에, **HSTS Preload 목록**을 사용하면 브라우저가 사이트를 처음 방문하기 전부터 HTTPS를 강제하도록 할 수 있다.

```http
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

- `preload` 옵션을 추가하면 HSTS Preload 목록에 등록 가능
- 크롬, 파이어폭스 등의 브라우저에서 사전 로드 목록을 활용하여 처음부터 HTTPS만 사용

### 6.4 HSTS가 필요한 경우

- 금융, 쇼핑몰 등 보안이 중요한 사이트
- 로그인 페이지 및 민감한 데이터를 다루는 서비스
- 공용 네트워크에서 사용될 가능성이 있는 서비스 (예: 카페 Wi-Fi에서의 접속 보호)
